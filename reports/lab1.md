# 实验做法

为 ```TaskControlBlock``` 添加了 ```start_time``` 和 ```pub syscall_times``` 分别用于记录任务的开始时间和各个系统调用的次数，并且在 ```TASK_MANAGER``` 添加初始化（全部为0）。

函数 ```pub fn sys_task_info(_ti: *mut TaskInfo) -> isize``` 直接获取当前任务的相关信息，并且输出。

更新每一个系统调用函数，通过函数 ```pub fn add_current_syscall_times(syscall_id: usize)``` 来增加次数。

# 问答题

## 1

直接卡死了

## 1

内存栈顶；1. 处理完异常；2. 从内核态回到用户态

## 2

处理了三个 CSR，sstatus、sepc 和 sscratch。

1. sstatus 的 SIE 位控制是否启用设备中断；SPP 位指示异常发生前的特权级别。
2. sepc 寄存器保存了异常发生时的指令地址。
3. sscratch 寄存器保存了一个内核可以自由使用的值。

## 3

```x2``` 是栈指针，```x4``` 是线程指针

## 4, 6

互相交换

## 5

```sret```

7

```ecall```


# 荣誉准则

我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

